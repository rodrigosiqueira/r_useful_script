#!/usr/bin/env Rscript

# Copyright (C) 2016 Rodrigo Siqueira
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.

# Convert date string and concatenate it with time to make possible the
# conversion from string to POSIX date time
# @param date String date in the format 'YYYYMMDD'
# @param time Time in the formate 'HH:MM:SS'
# @return List of POSIX date
date_time_to_posix <- function(date, time)
{
  year <- substring(date, 1, 4)
  mounth <- substring(date, 5, 6)
  day <- substring(date, 7, 9)

  date <- paste(year, mounth, day, sep='-')
  string_to_convert <- paste(date, time)

  posix_date <- as.POSIXct(string_to_convert)

  return(posix_date)
}

# Read raw data generated by collectl.
# @param path_origin Path to raw data generated by collectl related with Memory
# @return Return a list, with the following informations: date, time, and data
load_memory_data <- function(path_origin)
{
    # Read all file
    raw_data <- read.table(path_origin)

    # Separate Date and Time information from raw file. Unify column 1 and 2
    time_column <- raw_data[ ,1:2]
    time_column <- setNames(time_column, c('Date', 'Time'))
    posix_date <- date_time_to_posix(time_column$Date, time_column$Time)

    # The last field of cpu_cores keeps the information about date and time
    memory_info <- raw_data[ ,3:length(raw_data)]
    memory_info[length(memory_info) + 1] <- posix_date
    memory_label <- c('Used', 'Free', 'Slab', 'Mapped', 'Anon', 'AnonH',
                      'Inactive', 'Hits', 'PosixDate')
    memory_info <- setNames(memory_info, memory_label)
    return (memory_info)
}

# Plot memory utilization
# @param save_to
# @param values_to_plot
plot_used_memory <- function(save_to, values_to_plot)
{
  names_line <- names(values_to_plot)
  total_elements <- length(values_to_plot)
  colors <- c('blue', 'green', 'red', 'orange', 'black', 'grey', 'navy')
  set_of_data <- c()
  xlabel <- 'Time (s)'
  ylabel <- 'Used Memory (Gb)'
  kb_to_gb <- 1048576
  limit_on_y <- 0
  limit_on_x <- 0
  index <- 1

  # Load data, find max value for X and create label variables
  for (line in names_line)
  {
    loaded_file <- load_memory_data(values_to_plot[[line]])
    set_of_data[[line]] <- loaded_file
    total_of_elements <- length(loaded_file$Used)

    beginning_at <- min(loaded_file$PosixDate)
    finished_at <- max(loaded_file$PosixDate)
    elapsed_time <- abs(finished_at - beginning_at)

    limit_on_y <- max(0, loaded_file$Used / kb_to_gb, limit_on_y)

    if (index == 1)
    {
      limit_on_x <- elapsed_time
      index <- index + 1
      next
    }
    limit_on_x <- max(elapsed_time, limit_on_x)
  }

  # Setups
  margin <- c(5.1, 5.1, 2, 9.1)
  png(save_to, width=1024, height=768)
  par(mar=margin, xpd=TRUE)
  
  # Note: The last element of memory_data it is date and time in POSIX format.
  first_line <- set_of_data[[1]]
  yrange <- c(0, limit_on_y)
  xrange <- c(0, limit_on_x)
  plot(first_line$Used / kb_to_gb, type='l',
       ylim=yrange, xlim=xrange, col=colors[1], cex.lab=1.5, lty=1, ylab=ylabel,
       xlab=xlabel, cex.lab=1.5, lwd=2,
       cex.axis=1.5, cex.main=1.5)
  # First element is ignored because of first plot
  color_index <- 2
  names_line <- tail(names_line, n=length(names_line) - 1)
  for (key in names_line)
  {
    current_data <- set_of_data[[key]]
    lines(current_data$Used / kb_to_gb, type='l',
          col=colors[color_index], lwd=2)
    color_index <- color_index + 1
  }

  # Legend
  legend_color <- head(colors, n=total_elements)
  legend_lty <- rep(1, total_elements)
  legend_lwd <- rep(2.5, total_elements)
  legend('topright', inset=c(-0.15,0), legend=names(values_to_plot),
         lty=legend_lty, lwd=legend_lwd, col=legend_color)
  dev.off()
  return (0)
}

#------------------------------------------------------------------------------
# Handling script execution
#------------------------------------------------------------------------------
# Read arguments
pathsArguments <- commandArgs(trailingOnly=TRUE)

# Verify arguments, before start
argumentsLength <- length(pathsArguments)
if (((argumentsLength %% 2) == 0) | (argumentsLength < 3))
{
  message <- 'missing file operand'
  usage <- 'Rscript memory_graph.R SAVE_IMAGE LINE_NAME FILE_TO_PLOT ...'
  message <- paste(message, usage, sep='\n')
  stop(message)
} else
{
  index <- 1
  parameters <- c()
  for (name in pathsArguments)
  {
     # Image path to save
     if (index == 1)
     {
        saveTo <- pathsArguments[index]
     }
     # Names are even number
     else if (index %% 2 == 0)
     {
       nameIndex <- pathsArguments[index]
     }
     # Values are odd number
     else
     {
      parameters[[nameIndex]] <- pathsArguments[index]
     }
     index <- index + 1
  }
}

plot_used_memory(saveTo, parameters)
